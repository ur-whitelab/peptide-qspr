import numpy
import math
ALPHABET = ['A','R','N','D','C','Q','E','G','H','I', 'L','K','M','F','P','S','T','W','Y','V']
        
def pep_to_int_list( pep):
    '''Takes a single string of amino acids and translates to a list of ints'''
    return(list(map(ALPHABET.index, pep.replace('\n', ''))))


def get_hist_prob( bins, counts, value):
    '''takes in the bins and counts from a histogram (not necessarily normalized)
    and a value, returns the height of the bin that value falls into.'''
    idx = numpy.argmax(bins > value)
    if idx==0:
        return(0)
    else:
        return(counts[idx-1]/numpy.sum(counts))


def read_logs( trainfile, testfile, return_strings = False):
    '''Reads in the log files generated by training runs.'''
    train_data = {}#dict keyed by peptide length containing the sequences
    test_data = {}
    peptide_strings = {}
    train_peptides = []
    test_peptides = []
    big_aa_string = ''#for training the whole background distro
    with open(trainfile, 'r') as f:
        lines = f.readlines()
        nlines = len(lines)
        start_idx = (1 if ('#' in lines[0] or 'sequence' in lines[0]) else 0)
        for line in lines[start_idx:]:#skip the header
            pep = line.split(',')[0]
            train_peptides.append(pep)
            length = len(pep)
            big_aa_string+=pep
            if(length not in train_data.keys()):
                train_data[length] = [(pep_to_int_list(pep))]
            else:
                train_data[length].append((pep_to_int_list(pep)))
            if(length not in peptide_strings.keys()):
                peptide_strings[length] = [pep]
            else:
                peptide_strings[length].append(pep)
    with open(testfile, 'r') as f:
        lines = f.readlines()
        nlines = len(lines)
        start_idx = (1 if ('#' in lines[0] or 'sequence' in lines[0]) else 0)
        for line in lines[start_idx:]:#skip the header
            pep = line.split(',')[0]
            test_peptides.append(pep)
            length = len(pep)
            big_aa_string+=pep
            if(length not in test_data.keys()):
                test_data[length] = [(pep_to_int_list(pep))]
            else:
                test_data[length].append((pep_to_int_list(pep)))
            if(length not in peptide_strings.keys()):
                peptide_strings[length] = [pep]
            else:
                peptide_strings[length].append(pep)
    big_aa_list = pep_to_int_list(big_aa_string)
    if(return_strings):
        return(train_peptides, test_peptides, train_data, test_data, big_aa_list, peptide_strings)
    else:
        return(train_peptides, test_peptides, train_data, test_data, big_aa_list)

def calc_positives(arr, cutoff):
    '''takes in an array of probs given by the above model and returns the number of
       probs above the cutoff probability. This is for use in generating the ROC curve.'''
    if(len(arr) == 0):
        return(0)
    arr = numpy.sort(numpy.array(arr))
    if not arr[-1] < cutoff:
        return(len(arr) - numpy.argmax(arr > cutoff))
    else:
        return(0)

def gen_roc_data(npoints, roc_min, roc_max, fakes,
                 devs, trains):
    '''This fills two numpy arrays for use in plotting the ROC curve. The first is the FPR,
       the second is the TPR. The number of points is numpy.ints. Returns (FPR_arr, TPR_arr).'''
    best_cutoff = 0.0
    best_ROC = 0.0
    roc_range = numpy.linspace(roc_min, roc_max, npoints)
    fpr_arr = numpy.zeros(npoints)
    fp_arr = numpy.zeros(npoints)
    tnr_arr = numpy.zeros(npoints)
    tn_arr = numpy.zeros(npoints)
    tpr_arr = numpy.zeros(npoints)
    tp_arr = numpy.zeros(npoints)
    fnr_arr = numpy.zeros(npoints)
    fn_arr = numpy.zeros(npoints)
    #for each cutoff value, calculate the FPR and TPR
    for i in range(npoints):
        fp_arr[i] = calc_positives(fakes, roc_range[i])
        tn_arr[i] = len(fakes) - fp_arr[i]
        devset_positives =  calc_positives(devs, roc_range[i])
        devset_negatives = len(devs) - devset_positives
        trainset_positives = calc_positives(trains, roc_range[i])
        trainset_negatives = len(trains) - trainset_positives
        tp_arr[i] = devset_positives + trainset_positives
        fn_arr[i] = devset_negatives + trainset_negatives
    fpr_arr = fp_arr.astype(numpy.float32)/float(len(fakes))
    tnr_arr = fn_arr.astype(numpy.float32)/float(len(fakes))
    tpr_arr = tp_arr.astype(numpy.float32) / float(len(devs) + len(trains) )
    fnr_arr = fn_arr.astype(numpy.float32) / float(len(devs) + len(trains) )
    
    best_idx = 0
    best_fp = -1
    best_tp = -1
    best_fn = -1
    best_tn = -1
    old_dist = 2.0
    for i in range(0,npoints-1):
        dist = math.sqrt(2.0 * fpr_arr[i] **2 +  (1-tpr_arr[i]) **2)
        if (old_dist > dist):
            best_idx = i
            old_dist = dist
    best_cutoff = roc_range[best_idx]
    accuracy = float(tn_arr[best_idx] + tp_arr[best_idx]) / float(len(devs) + len(trains) + len(fakes))#(tpr_arr[best_idx] * float(len(devs)+len(trains)) + (tnr_arr[best_idx]))*float(len(fakes))/float(len(devs)+len(trains)+len(fakes))
    print('TP was {}, FP was {}, TN was {}, FN was {}, ACC was {}'.format(tp_arr[best_idx], fp_arr[best_idx], tn_arr[best_idx], fn_arr[best_idx], accuracy))
    return( (fpr_arr, tpr_arr, accuracy, best_cutoff, best_idx))

def calc_prob(peptide, bg_dist,  motif_dists, motif_start=None, motif_class=None, motif_length=None, num_motif_classes=None):
    '''For use when we're OUTSIDE the model. Optionally gives prob with the motif starting 
    at a specified location and/or with the motif class specified. If not specified,
    loops over all possibilities for both/either.'''
    length = len(peptide)
    if(motif_start is None):#loop through all the motif classes available
        if(length - motif_length +1 > 0 and motif_length > 0):
            start_dist = numpy.ones(length - motif_length +1) /(length-motif_length+1)#uniform start dists
            prob = 0.0
            for i in range(length):
                for j in range(length - motif_length+1):
                    for k in range(num_motif_classes):
                        if(i < j or i >= j+motif_length):#not in a motif 
                            prob += bg_dist[peptide[i]] * start_dist[j]
                        else:#we are in a motif
                            if(motif_class is None):
                                prob += motif_dists[k][i-j][peptide[i]] * start_dist[j]
                            else:
                                prob += motif_dists[motif_class][i-j][peptide[i]] * start_dist[j]
        else:#impossible to have a motif of this length, all b/g
            prob = 0.0
            for i in range(length):
                prob += bg_dist[peptide[i]]
    else:#motif_class is fixed. for comparable magnitudes we loop the same number of times
        if(length - motif_length +1 > 0 and motif_length > 0):
            start_dist = numpy.ones(length - motif_length +1) /(length-motif_length+1)#uniform start dists
            prob = 0.0
            for i in range(length):
                for j in range(length - motif_length+1):
                    for k in range(num_motif_classes):
                        if(i < motif_start or i >= motif_start+motif_length):#not in a motif 
                            prob += bg_dist[peptide[i]] * start_dist[motif_start]
                        else:#we are in a motif
                            if(motif_class is None):
                                prob += motif_dists[k][i-motif_start][peptide[i]] * start_dist[motif_start]
                            else:
                                prob += motif_dists[motif_class][i-motif_start][peptide[i]] * start_dist[motif_start]
        else:#impossible to have a motif of this length, all b/g
            prob = 0.0
            for i in range(length):
                prob += bg_dist[peptide[i]]
    prob /= float(length)
    return(prob)


def get_tot_prob(peptide, bg_dist,  motif_dists, class_dist, start_dist, motif_class=None, motif_start=None ):
    '''Takes in a single peptide as a LIST OF INTS, the background distro, the
       dict of motif distros, either the class distro OF THE SPECIFIC PEPTIDE
       or the set motif class, and either the motif start position or the start 
       distros. Returns the total probability
       density assigned to the sequence by the model. This is called during sampling AND
       during calculation of ROC data, so it has to handle taking in distros or set values for both
       motif start and motif class in any combination (4 cases).'''
    length = len(peptide)
    prob = 0.0
    #for use during Gibbs steps, when start position is given (sampled)
    if motif_start is not None:#use set start position
        if motif_class is not None:#use set class value
            for i in range(length):#loop over all AA
                for j in range(length - MOTIF_LENGTH + 1):
                    for k in range(NUM_MOTIF_CLASSES):
                        #we know where the motif is
                        if(i < motif_start or i >= motif_start + MOTIF_LENGTH):#\geq because of indexing
                            prob += bg_dist[peptide[i]] * start_dist[j] * class_dist[motif_class]
                        else:
                            prob += motif_dists[motif_class][ i - motif_start][peptide[i]] * start_dist[j] * class_dist[motif_class]
        else:#motif_class is None -> use distros
            for i in range(length):
                for j in range(length - MOTIF_LENGTH + 1):
                    for k in range(NUM_MOTIF_CLASSES):
                        if(i < motif_start or i >= motif_start + MOTIF_LENGTH):#not in a motif
                            prob += bg_dist[peptide[i]]* start_dist[j] * class_dist[k]
                        else:#in a motif
                            prob += motif_dists[k][i - motif_start][peptide[i]] * start_dist[j] * class_dist[k]
                            #for use during evaluation & finding ROC data
    else:#start_dist is not None -> use distros, no set value
        if motif_class is not None:#use set class value but draw from start position distro
            for i in range(length):
                for j in range(length - MOTIF_LENGTH+1):#all possible motif start positions
                    for k in range(NUM_MOTIF_CLASSES):
                        if( i < j or i >= j+MOTIF_LENGTH):#we're not in a motif
                            prob += bg_dist[peptide[i]] * start_dist[j] * class_dist[k]
                        else:#we're in a motif
                            prob += motif_dists[motif_class][i - j][peptide[i]] * start_dist[j] * class_dist[motif_class]
        else:#don't know class value OR motif start value. iterate through both...
            for i in range(length):
                for j in range(length - MOTIF_LENGTH+1):
                    for k in range(NUM_MOTIF_CLASSES):
                        if(i < j or i >= j+MOTIF_LENGTH):#not in a motif 
                            prob += bg_dist[peptide[i]] * start_dist[j] * class_dist[k]
                        else:#we are in a motif 
                            prob += motif_dists[k][i-j][peptide[i]] * start_dist[j]* class_dist[k]
    return(prob)

def read_data(datafile):
    '''Takes a properly-formatted peptide datafile (each line MUST start with a sequence)
       and reads it into a list.'''
    data = {}#dict keyed by peptide length containing the sequences
    with open(datafile, 'r') as f:
        big_aa_string = ''#for training the whole background distro
        lines = f.readlines()
        nlines = len(lines)
        start_idx = (1 if ('#' in lines[0] or 'sequence' in lines[0]) else 0)
        for line in lines[start_idx:]:#skip the header
            pep = line.split(',')[0]
            length = len(pep)
            big_aa_string+=pep
            if(length not in data.keys()):
                data[length] = [(pep_to_int_list(pep))]
            else:
                data[length].append((pep_to_int_list(pep)))
        big_aa_list = pep_to_int_list(big_aa_string)
    return(data, big_aa_list)



